<?xml version="1.0" encoding="UTF-8"?>
<!--Designed and generated by Altova StyleVision Enterprise Edition 2016 sp1 - see http://www.altova.com/stylevision for more information.-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:altova="http://www.altova.com" xmlns:altova-xfi="http://www.altova.com/xslt-extensions/xbrl" xmlns:altovaext="http://www.altova.com/xslt-extensions" xmlns:array="http://www.w3.org/2005/xpath-functions/array" xmlns:clitype="clitype" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:iso4217="http://www.xbrl.org/2003/iso4217" xmlns:ix="http://www.xbrl.org/2008/inlineXBRL" xmlns:java="java" xmlns:link="http://www.xbrl.org/2003/linkbase" xmlns:map="http://www.w3.org/2005/xpath-functions/map" xmlns:math="http://www.w3.org/2005/xpath-functions/math" xmlns:n1="http://hl7.org/fhir" xmlns:sps="http://www.altova.com/StyleVision/user-xpath-functions" xmlns:xbrldi="http://xbrl.org/2006/xbrldi" xmlns:xbrli="http://www.xbrl.org/2003/instance" xmlns:xff="http://www.xbrl.org/2010/function/formula" xmlns:xfi="http://www.xbrl.org/2008/function/instance" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" exclude-result-prefixes="#all" xmlns="http://www.w3.org/1999/xhtml">
	<xsl:output method="xml" version="1.0" encoding="UTF-8" indent="yes"/>
	<xsl:character-map name="spaces">
		<xsl:output-character character="&#160;" string="&amp;nbsp;"/>
	</xsl:character-map>
	<!--   extension urls here:-->
		<xsl:param name="ext1" select="'http://hl7.org/fhir/StructureDefinition/capabilitystatement-search-parameter-combination'"/>
			<xsl:param name="ext2" select="'http://hl7.org/fhir/StructureDefinition/capabilitystatement-expectation'"/>
					<xsl:param name="ext3" select="'http://hl7.org.au/fhir/argonaut/StructureDefinition/argo-fromResource'"/>
					
	<xsl:param name="altova:bGeneratingFromPxf" select="false()"/>
	<xsl:param name="SV_OutputFormat" select="'HTML'"/>
	<xsl:param name="SV_BaseOutputFileName" as="xs:string?">
		<xsl:sequence select="for $i in altovaext:get-base-output-uri(), $j in tokenize( $i, &apos;[/\\]&apos; )[last()] return replace( $j, &apos;\.[^\.\s#%;]*$&apos;, &apos;&apos; )" use-when="function-available(&apos;altovaext:get-base-output-uri&apos;)"/>
	</xsl:param>
	<xsl:param name="SV_GeneratedFileNamePrefix" select="if ( $SV_BaseOutputFileName ) then $SV_BaseOutputFileName else &apos;capstmtn&apos;" as="xs:string?"/>
	<xsl:variable name="XML" select="/"/>
	<xsl:param name="XML2"/>
	<xsl:variable name="altova:nPxPerIn" select="96"/>
	<xsl:variable name="altova:CssImages" select="()"/>
	<xsl:template match="@*|node()">
		<xsl:copy>
			<xsl:apply-templates select="@*|node()"/>
		</xsl:copy>
	</xsl:template>
	 <!-- Override for target element -->
<xsl:template match="n1:id">
  <!-- Copy the element -->
    <xsl:copy>
      <!-- And everything inside it -->
      <xsl:apply-templates select="@* | *"/> 
    </xsl:copy>
		
	  <!-- Append new node (or whatever else you wanna do) -->

			<text xmlns="http://hl7.org/fhir">
				<status xmlns="http://hl7.org/fhir" value="generated"/>
				<div xmlns="http://www.w3.org/1999/xhtml"> 
				
	  <!-- generated xhtml here -->		
	  	<xsl:variable name="altova:Design">
			<xsl:call-template name="altova:Root"/>
		</xsl:variable>
		<xsl:apply-templates select="$altova:Design" mode="altova:WriteResultDoc"/>
	  
				</div>
				</text>



				</xsl:template>
				

	<xsl:template name="altova:Root">
		<xsl:variable name="XML2" select="document($XML2)"/>
		<xsl:for-each select="$XML">
			<xsl:for-each select="n1:CapabilityStatement">
				<xsl:for-each select="n1:name">
					<xsl:for-each select="@value">
						<span style="font-size:larger; font-weight:bold; ">
							<xsl:value-of select="string(.)"/>
						</span>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
		</xsl:for-each>
		<hr/>
		<p>
			<span>
				<xsl:text>FHIR Version: </xsl:text>
			</span>
			<xsl:for-each select="$XML">
				<xsl:for-each select="n1:CapabilityStatement">
					<xsl:for-each select="n1:fhirVersion">
						<xsl:for-each select="@value">
							<span>
								<xsl:value-of select="string(.)"/>
							</span>
						</xsl:for-each>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
			<br/>
			<span>
				<xsl:text>Supported formats: </xsl:text>
			</span>
			<xsl:for-each select="$XML">
				<xsl:for-each select="n1:CapabilityStatement">
					<xsl:for-each select="n1:format">
						<xsl:for-each select="@value">
							<span>
								<xsl:value-of select="string(.)"/>
							</span>
						</xsl:for-each>
						<xsl:if test="position() != last()">
							<span>
								<xsl:text>, </xsl:text>
							</span>
						</xsl:if>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
			<br/>
			<span>
				<xsl:text>Published: </xsl:text>
			</span>
			<xsl:for-each select="$XML">
				<xsl:for-each select="n1:CapabilityStatement">
					<xsl:for-each select="n1:date">
						<xsl:for-each select="@value">
							<span>
								<xsl:value-of select="string(.)"/>
							</span>
						</xsl:for-each>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
			<br/>
			<span>
				<xsl:text>Published by: </xsl:text>
			</span>
			<xsl:for-each select="$XML">
				<xsl:for-each select="n1:CapabilityStatement">
					<xsl:for-each select="n1:publisher">
						<xsl:for-each select="@value">
							<span>
								<xsl:value-of select="string(.)"/>
							</span>
						</xsl:for-each>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
		</p>
		<p>
			<xsl:for-each select="$XML">
				<xsl:for-each select="n1:CapabilityStatement">
					<xsl:for-each select="n1:description">
						<xsl:for-each select="@value">
							<span>
								<xsl:value-of select="string(.)"/>
							</span>
						</xsl:for-each>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
		</p>
		<br/>
		<h4>
			<span style="font-size:larger; font-weight:bold; ">
				<xsl:text>RESTful Behavior</xsl:text>
			</span>
		</h4>
		<br/>
		<hr/>
		<div>
			<span>
				<xsl:text>Description: </xsl:text>
			</span>
			<xsl:for-each select="$XML">
				<xsl:for-each select="n1:CapabilityStatement">
					<xsl:for-each select="n1:rest">
						<xsl:for-each select="n1:documentation">
							<xsl:for-each select="@value">
								
									<altova:UnescapedText>
										<xsl:value-of select="string(.)"/>
									</altova:UnescapedText>
								
							</xsl:for-each>
						</xsl:for-each>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
			<br/>
		</div>
		<div>
			<span>
				<xsl:text>Security: </xsl:text>
			</span>
			<xsl:for-each select="$XML">
				<xsl:for-each select="n1:CapabilityStatement">
					<xsl:for-each select="n1:rest">
						<xsl:for-each select="n1:security">
							<xsl:for-each select="n1:description">
								<xsl:for-each select="@value">
									
										<altova:UnescapedText>
											<xsl:value-of select="string(.)"/>
										</altova:UnescapedText>
							
								</xsl:for-each>
							</xsl:for-each>
						</xsl:for-each>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
			<br/>
		</div>
				<xsl:choose>
					<xsl:when test="boolean(n1:CapabilityStatement/n1:rest/n1:operation)">
						<div>
							<span>
								<xsl:text>Supported Operations: </xsl:text>
							</span>
							<xsl:for-each select="$XML">
								<xsl:for-each select="n1:CapabilityStatement">
									<xsl:for-each select="n1:rest">
										<xsl:for-each select="n1:operation">
											<xsl:for-each select="n1:extension">
												<xsl:for-each select="n1:valueCode">
													<xsl:for-each select="@value">
														<span style="font-weight:bold;">
															<xsl:value-of select="string(.)"/>
														</span>
													</xsl:for-each>
												</xsl:for-each>
												<span>
													<xsl:text> Support </xsl:text>
												</span>
											</xsl:for-each>
											<a>
												<xsl:choose>
													<xsl:when test="not(string(n1:definition/n1:reference/@value))">
														<xsl:attribute name="href">
															<xsl:text>#</xsl:text>
														</xsl:attribute>
													</xsl:when>
													<xsl:when test="substring(string(n1:definition/n1:reference/@value), 1, 1) = '#'">
														<xsl:attribute name="href">
															<xsl:value-of select="n1:definition/n1:reference/@value"/>
														</xsl:attribute>
													</xsl:when>
													<xsl:otherwise>
														<xsl:attribute name="href">
															<xsl:if test="substring(string(n1:definition/n1:reference/@value), 2, 1) = ':'">
																<xsl:text>file:///</xsl:text>
															</xsl:if>
															<xsl:value-of select="translate(string(n1:definition/n1:reference/@value), '&#x5c;', '/')"/>
														</xsl:attribute>
													</xsl:otherwise>
												</xsl:choose>
												<xsl:for-each select="n1:name">
													<xsl:for-each select="@value">
														<span>
															<xsl:value-of select="string(.)"/>
														</span>
													</xsl:for-each>
												</xsl:for-each>
											</a>
											<xsl:if test="position() != last()">
												<span>
													<xsl:text>, </xsl:text>
												</span>
											</xsl:if>
										</xsl:for-each>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:for-each>
						</div>
					</xsl:when>
					<xsl:otherwise>
						<span>
							<xsl:text>Supported Operations: </xsl:text>
						</span>
						<xsl:for-each select="$XML">
							<xsl:for-each select="n1:CapabilityStatement">
								<xsl:for-each select="n1:rest">
									<xsl:for-each select="n1:operation">
										<xsl:for-each select="n1:extension">
											<xsl:for-each select="n1:valueCode">
												<xsl:for-each select="@value">
													<span style="font-weight:bold;">
														<xsl:value-of select="string(.)"/>
													</span>
												</xsl:for-each>
											</xsl:for-each>
											<span>
												<xsl:text> Support </xsl:text>
											</span>
										</xsl:for-each>
										<a>
											<xsl:choose>
												<xsl:when test="not(string(n1:definition/n1:reference/@value))">
													<xsl:attribute name="href">
														<xsl:text>#</xsl:text>
													</xsl:attribute>
												</xsl:when>
												<xsl:when test="substring(string(n1:definition/n1:reference/@value), 1, 1) = '#'">
													<xsl:attribute name="href">
														<xsl:value-of select="n1:definition/n1:reference/@value"/>
													</xsl:attribute>
												</xsl:when>
												<xsl:otherwise>
													<xsl:attribute name="href">
														<xsl:if test="substring(string(n1:definition/n1:reference/@value), 2, 1) = ':'">
															<xsl:text>file:///</xsl:text>
														</xsl:if>
														<xsl:value-of select="translate(string(n1:definition/n1:reference/@value), '&#x5c;', '/')"/>
													</xsl:attribute>
												</xsl:otherwise>
											</xsl:choose>
											<xsl:for-each select="n1:name">
												<xsl:for-each select="@value">
													<span>
														<xsl:value-of select="string(.)"/>
													</span>
												</xsl:for-each>
											</xsl:for-each>
										</a>
										<xsl:if test="position() != last()">
											<span>
												<xsl:text>, </xsl:text>
											</span>
										</xsl:if>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:for-each>
					</xsl:otherwise>
				</xsl:choose>




		<h4>
			<span style="font-weight:bold; ">
				<xsl:text>Resource&#160; Details:</xsl:text>
			</span>
		</h4>
		<br/>
		<ol>
			<xsl:for-each select="$XML">
				<xsl:for-each select="n1:CapabilityStatement">
					<xsl:for-each select="n1:rest">
						<xsl:for-each select="n1:resource">
							<li>
								<span style="font-weight:bold; ">
									<xsl:text>Resource Type: </xsl:text>
								</span>
								<a>
									<xsl:attribute name="name">
										<xsl:value-of select="n1:type/@value"/>
									</xsl:attribute>
									<xsl:for-each select="n1:type">
										<xsl:for-each select="@value">
											<span style="font-weight:bold; ">
												<xsl:value-of select="string(.)"/>
											</span>
										</xsl:for-each>
									</xsl:for-each>
								</a>
								<p>
									<span>
										<xsl:text>Supported Profiles:&#160; </xsl:text>
									</span>
									<xsl:for-each select="n1:type">
										<xsl:for-each select="@value">
											<xsl:variable name="var" select="."/>
											<xsl:for-each select="$XML">
												<xsl:for-each select="n1:CapabilityStatement">
													<xsl:for-each select="n1:profile[n1:extension[@url=$ext3]/n1:valueCode/@value=$var]">
														<xsl:for-each select="n1:display">
															<a>
																<xsl:choose>
																	<xsl:when test="not(string(../n1:reference/@value))">
																		<xsl:attribute name="href">
																			<xsl:text>#</xsl:text>
																		</xsl:attribute>
																	</xsl:when>
																	<xsl:when test="substring(string(../n1:reference/@value), 1, 1) = '#'">
																		<xsl:attribute name="href">
																			<xsl:value-of select="../n1:reference/@value"/>
																		</xsl:attribute>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:attribute name="href">
																			<xsl:if test="substring(string(../n1:reference/@value), 2, 1) = ':'">
																				<xsl:text>file:///</xsl:text>
																			</xsl:if>
																			<xsl:value-of select="translate(string(../n1:reference/@value), '&#x5c;', '/')"/>
																		</xsl:attribute>
																	</xsl:otherwise>
																</xsl:choose>
																<xsl:for-each select="@value">
																	<span>
																		<xsl:value-of select="string(.)"/>
																	</span>
																	<br/>
																</xsl:for-each>
															</a>
														</xsl:for-each>
													</xsl:for-each>
												</xsl:for-each>
											</xsl:for-each>
											<br/>
										</xsl:for-each>
									</xsl:for-each>
								</p>
								<xsl:for-each select="n1:extension/n1:valueMarkdown">
									<xsl:for-each select="@value">
									
											<altova:UnescapedText>
												<xsl:value-of select="string(.)"/>
											</altova:UnescapedText>
								
									</xsl:for-each>
								</xsl:for-each>
								<p/>
								<p/>
								<xsl:if test="boolean(n1:extension[@url=$ext1]/n1:extension)">
									<p>
										<span>
											<xsl:text>Supported Search Combinations:</xsl:text>
										</span>
										<xsl:for-each select="n1:extension[@url=$ext1]">
											<xsl:for-each select="n1:extension">
												<xsl:for-each select="n1:valueString">
													<xsl:for-each select="@value">
														<span>
															<xsl:value-of select="string(.)"/>
														</span>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:if test="position() != last()">
													<span>
														<xsl:text> + </xsl:text>
													</span>
												</xsl:if>
											</xsl:for-each>
											<xsl:if test="position() != last()">
												<span>
													<xsl:text>, </xsl:text>
												</span>
											</xsl:if>
										</xsl:for-each>
									</p>
								</xsl:if>
								<xsl:if test="boolean(n1:searchInclude)">
									<p>
										<span>
											<xsl:text>Supported Includes: </xsl:text>
										</span>
										<xsl:for-each select="n1:searchInclude">
											<xsl:for-each select="@value">
												<span>
													<xsl:value-of select="string(.)"/>
												</span>
											</xsl:for-each>
											<xsl:if test="position() != last()">
												<span>
													<xsl:text>, </xsl:text>
												</span>
											</xsl:if>
										</xsl:for-each>
									</p>
								</xsl:if>
								<p/>
								<hr/>
							</li>
						</xsl:for-each>
					</xsl:for-each>
				</xsl:for-each>
			</xsl:for-each>
		</ol>
		<br/>
		<br/>
		<br/>
	</xsl:template>
<!--	
	<xsl:template match="n1:resource">
		<xsl:variable name="XML2" select="document($XML2)"/>
		<xsl:apply-templates/>
	</xsl:template>
	
-->	<xsl:function name="altova:is-cell-empty" as="xs:boolean">
		<xsl:param name="altova:cell" as="element()"/>
		<xsl:sequence select="altova:is-node-empty( $altova:cell )"/>
	</xsl:function>
	<xsl:function name="altova:is-node-empty" as="xs:boolean">
		<xsl:param name="altova:node" as="element()"/>
		<xsl:sequence select="every $altova:child in $altova:node/child::node() satisfies ( ( boolean( $altova:child/self::text() ) and string-length( $altova:child ) = 0 ) or ( ( boolean( $altova:child/self::xhtml:div ) or boolean( $altova:child/self::xhtml:span ) or boolean( $altova:child/self::xhtml:a ) ) and altova:is-node-empty( $altova:child ) ) )"/>
	</xsl:function>
	<xsl:function name="altova:col-span" as="xs:integer">
		<xsl:param name="altova:cell" as="element()"/>
		<xsl:sequence select="if ( exists( $altova:cell/@colspan ) ) then xs:integer( $altova:cell/@colspan ) else 1"/>
	</xsl:function>
	<xsl:template match="@* | node()" mode="altova:generate-table">
		<xsl:param name="altova:generate-cols"/>
		<xsl:param name="altova:TableIndexInfo"/>
		<xsl:copy>
			<xsl:apply-templates select="@* | node()" mode="#current">
				<xsl:with-param name="altova:generate-cols" select="$altova:generate-cols"/>
				<xsl:with-param name="altova:TableIndexInfo" select="$altova:TableIndexInfo"/>
			</xsl:apply-templates>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="xhtml:tbody" mode="altova:generate-table">
		<xsl:param name="altova:generate-cols"/>
		<xsl:param name="altova:TableIndexInfo"/>
		<xsl:choose>
			<xsl:when test="empty(xhtml:tr)">
				<xsl:copy>
					<tr>
						<td/>
					</tr>
				</xsl:copy>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current">
						<xsl:with-param name="altova:generate-cols" select="$altova:generate-cols"/>
						<xsl:with-param name="altova:TableIndexInfo" select="$altova:TableIndexInfo"/>
					</xsl:apply-templates>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="xhtml:th | xhtml:td" mode="altova:generate-table">
		<xsl:choose>
			<xsl:when test="altova:is-cell-empty( . )">
				<xsl:copy>
					<xsl:apply-templates select="@*" mode="#current"/>
					<xsl:text>&#160;</xsl:text>
				</xsl:copy>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy>
					<xsl:apply-templates select="@* | node()" mode="#current"/>
				</xsl:copy>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template match="@* | node()" mode="altova:WriteResultDoc">
		<xsl:copy>
			<xsl:apply-templates select="@* | node()" mode="#current"/>
		</xsl:copy>
	</xsl:template>
	<xsl:template match="altova:UnescapedText" mode="altova:WriteResultDoc">
		<xsl:value-of select="." disable-output-escaping="yes"/>
	</xsl:template>
	<xsl:function name="altova:CountLeadingTrueValues">
		<xsl:param name="seqBools"/>
		<xsl:sequence select="if (not($seqBools[1] = true())) then 0 else 1 + altova:CountLeadingTrueValues($seqBools[position() gt 1])"/>
	</xsl:function>
	<xsl:function name="altova:GetCellFromRow" as="node()?">
		<xsl:param name="nodeTableRow" as="node()"/>
		<xsl:param name="nCell" as="xs:integer"/>
		<xsl:sequence select="$nodeTableRow/(xhtml:th | xhtml:td)[$nCell]"/>
	</xsl:function>
	<xsl:function name="altova:GetCellsFromRow" as="node()*">
		<xsl:param name="nodeTableRow" as="node()"/>
		<xsl:sequence select="$nodeTableRow/(xhtml:th | xhtml:td)"/>
	</xsl:function>
	<xsl:function name="altova:GetRowsFromTable" as="node()*">
		<xsl:param name="nodeTable" as="node()"/>
		<xsl:sequence select="$nodeTable/(xhtml:thead | xhtml:tbody | xhtml:tfoot)/xhtml:tr"/>
	</xsl:function>
	<xsl:function name="altova:GetRowspanFromCell" as="xs:integer">
		<xsl:param name="altova:nodeCell" as="node()"/>
		<xsl:variable name="altova:sRowSpan" select="$altova:nodeCell/@rowspan" as="xs:string?"/>
		<xsl:variable name="altova:nRowSpan" select="if ($altova:sRowSpan) then xs:integer($altova:sRowSpan) else 1" as="xs:integer"/>
		<xsl:sequence select="$altova:nRowSpan"/>
	</xsl:function>
	<!-- In HTML and FO, the table section order is header, footer, body. This function determines, for a given cell, the number its row would have if the section order were header, body, footer -->
	<xsl:function name="altova:GetGridRowNumForCell">
		<xsl:param name="altova:nodeTableCell" as="node()"/>
		<xsl:variable name="altova:nodeTableRow" select="$altova:nodeTableCell/.." as="node()"/>
		<xsl:variable name="altova:nodeTableSection" select="$altova:nodeTableRow/.." as="node()"/>
		<xsl:variable name="altova:sTableSection" select="fn:local-name($altova:nodeTableSection)" as="xs:string"/>
		<xsl:variable name="altova:nodeTable" select="$altova:nodeTableSection/.." as="node()"/>
		<xsl:variable name="altova:nRowNumInSection" select="count($altova:nodeTableRow/preceding-sibling::xhtml:tr) + 1" as="xs:integer"/>
		<xsl:choose>
			<xsl:when test="$altova:sTableSection eq 'tbody'">
				<xsl:sequence select="count($altova:nodeTable/xhtml:thead/xhtml:tr) + $altova:nRowNumInSection"/>
			</xsl:when>
			<xsl:when test="$altova:sTableSection eq 'thead'">
				<xsl:sequence select="$altova:nRowNumInSection"/>
			</xsl:when>
			<xsl:when test="$altova:sTableSection eq 'tfoot'">
				<xsl:sequence select="count($altova:nodeTable/xhtml:thead/xhtml:tr) + count($altova:nodeTable/xhtml:tbody/xhtml:tr) + $altova:nRowNumInSection"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:message select="'Internal Error'" terminate="yes"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:BuildTableIndexInfo" as="node()">
		<xsl:param name="altova:nodeTable" as="node()"/>
		<altova:ColumnIndices>
			<xsl:variable name="altova:nodeAllRows" select="altova:GetRowsFromTable($altova:nodeTable/xhtml:table)" as="node()*"/>
			<xsl:if test="$altova:nodeAllRows">
				<xsl:variable name="altova:seqCellsInFirstRow" select="altova:GetCellsFromRow($altova:nodeAllRows[1])" as="node()*"/>
				<xsl:variable name="altova:nColumnsInTable" select="sum(for $nodeCell in $altova:seqCellsInFirstRow return altova:col-span($nodeCell))" as="xs:integer"/>
				<xsl:variable name="altova:seqActiveRowSpans" select="for $Cell in 1 to $altova:nColumnsInTable return 0" as="xs:integer*"/>
				<!--xsl:sequence select="altova:BuildTableIndexInfo_Recursive($altova:nodeAllRows, 1, $altova:seqActiveRowSpans)"/-->
				<xsl:call-template name="altova:BuildTableIndexInfo_Recursive">
					<xsl:with-param name="altova:nodeTableRows" select="$altova:nodeAllRows"/>
					<xsl:with-param name="altova:nRow" select="1"/>
					<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans"/>
				</xsl:call-template>
			</xsl:if>
		</altova:ColumnIndices>
	</xsl:function>
	<!--xsl:template name="altova:BuildTableIndexInfo_Recursive" as="node()*"-->
	<xsl:template name="altova:BuildTableIndexInfo_Recursive">
		<xsl:param name="altova:nodeTableRows" as="node()*"/>
		<xsl:param name="altova:nRow" as="xs:integer"/>
		<xsl:param name="altova:seqActiveRowSpans" as="xs:integer*"/>
		<xsl:variable name="altova:nodeRow" select="$altova:nodeTableRows[$altova:nRow]" as="node()?"/>
		<xsl:choose>
			<xsl:when test="empty($altova:nodeRow)">
				<xsl:sequence select="()"/>
			</xsl:when>
			<xsl:when test="empty(altova:GetCellFromRow($altova:nodeRow, 1))">
				<xsl:sequence select="()"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:nodeCell1" select="altova:GetCellFromRow($altova:nodeRow, 1)" as="node()?"/>
				<xsl:variable name="altova:nColSpan" select="altova:col-span($altova:nodeCell1)" as="xs:integer"/>
				<altova:Row>
					<!--xsl:variable name="altova:seqColumnIndicesOfCurrentRow" select="altova:BuildTableIndexInfo_SingleRow_Recursive($altova:seqActiveRowSpans, $altova:nodeRow, 1, 1, $altova:nColSpan, true(), 0, 0)" as="node()*"/>
						<xsl:sequence select="$altova:seqColumnIndicesOfCurrentRow"/-->
					<xsl:call-template name="altova:BuildTableIndexInfo_SingleRow_Recursive">
						<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans"/>
						<xsl:with-param name="altova:nodeRow" select="$altova:nodeRow"/>
						<xsl:with-param name="altova:nColumn" select="1"/>
						<xsl:with-param name="altova:nCellInCurrentRow" select="1"/>
						<xsl:with-param name="altova:nColSpanInCellRemaining" select="$altova:nColSpan"/>
						<xsl:with-param name="altova:bColSpanBegins" select="true()"/>
						<xsl:with-param name="altova:nCurrentSum" select="0"/>
						<xsl:with-param name="altova:nRowSpansToAdd" select="0"/>
					</xsl:call-template>
				</altova:Row>
				<xsl:variable name="altova:seqActiveRowSpans_New" select="altova:BuildTableIndexInfo_ActiveRowSpans_Recursive($altova:seqActiveRowSpans, $altova:nodeRow, 1, 1, $altova:nColSpan)" as="xs:integer*"/>
				<!--xsl:sequence select="altova:BuildTableIndexInfo_Recursive($altova:nodeTableRows, $altova:nRow + 1, $altova:seqActiveRowSpans_New)"/-->
				<xsl:call-template name="altova:BuildTableIndexInfo_Recursive">
					<xsl:with-param name="altova:nodeTableRows" select="$altova:nodeTableRows"/>
					<xsl:with-param name="altova:nRow" select="$altova:nRow + 1"/>
					<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans_New"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!--xsl:template name="altova:BuildTableIndexInfo_SingleRow_Recursive" as="node()*"-->
	<xsl:template name="altova:BuildTableIndexInfo_SingleRow_Recursive">
		<xsl:param name="altova:seqActiveRowSpans" as="xs:integer*"/>
		<xsl:param name="altova:nodeRow" as="node()"/>
		<xsl:param name="altova:nColumn" as="xs:integer"/>
		<xsl:param name="altova:nCellInCurrentRow" as="xs:integer"/>
		<xsl:param name="altova:nColSpanInCellRemaining" as="xs:integer"/>
		<xsl:param name="altova:bColSpanBegins" as="xs:boolean"/>
		<!-- Also true if it's just a single cell -->
		<xsl:param name="altova:nCurrentSum" as="xs:integer"/>
		<xsl:param name="altova:nRowSpansToAdd" as="xs:integer"/>
		<xsl:choose>
			<xsl:when test="$altova:nColumn gt count($altova:seqActiveRowSpans)">
				<xsl:sequence select="()"/>
			</xsl:when>
			<!-- If the cell is not under a rowspan -->
			<xsl:when test="$altova:seqActiveRowSpans[$altova:nColumn] eq 0">
				<!-- If the cell is not under a colspan -->
				<xsl:if test="$altova:bColSpanBegins eq true()">
					<!-- A non-spanned cell starts in this column -->
					<altova:ColumnIndex>
						<xsl:sequence select="$altova:nCurrentSum + 1"/>
					</altova:ColumnIndex>
				</xsl:if>
				<xsl:variable name="altova:nCellInCurrentRow_New" select="if ($altova:nColSpanInCellRemaining gt 1) then $altova:nCellInCurrentRow else $altova:nCellInCurrentRow + 1" as="xs:integer"/>
				<xsl:variable name="altova:nColSpanInCell_New" select="if ($altova:nColSpanInCellRemaining gt 1) then $altova:nColSpanInCellRemaining - 1 else if (empty(altova:GetCellFromRow($altova:nodeRow, $altova:nCellInCurrentRow_New))) then 1 else altova:col-span(altova:GetCellFromRow($altova:nodeRow, $altova:nCellInCurrentRow_New))" as="xs:integer"/>
				<xsl:variable name="altova:bColSpanBegins_New" select="$altova:nCellInCurrentRow ne $altova:nCellInCurrentRow_New" as="xs:boolean"/>
				<!--xsl:sequence select="altova:BuildTableIndexInfo_SingleRow_Recursive($altova:seqActiveRowSpans, $altova:nodeRow, $altova:nColumn + 1, $altova:nCellInCurrentRow_New, $altova:nColSpanInCell_New, $altova:bColSpanBegins_New, $altova:nCurrentSum + 1, $altova:nRowSpansToAdd)"/-->
				<xsl:call-template name="altova:BuildTableIndexInfo_SingleRow_Recursive">
					<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans"/>
					<xsl:with-param name="altova:nodeRow" select="$altova:nodeRow"/>
					<xsl:with-param name="altova:nColumn" select="$altova:nColumn + 1"/>
					<xsl:with-param name="altova:nCellInCurrentRow" select="$altova:nCellInCurrentRow_New"/>
					<xsl:with-param name="altova:nColSpanInCellRemaining" select="$altova:nColSpanInCell_New"/>
					<xsl:with-param name="altova:bColSpanBegins" select="$altova:bColSpanBegins_New"/>
					<xsl:with-param name="altova:nCurrentSum" select="$altova:nCurrentSum + 1"/>
					<xsl:with-param name="altova:nRowSpansToAdd" select="$altova:nRowSpansToAdd"/>
				</xsl:call-template>
			</xsl:when>
			<!-- The cell is under a rowspan -->
			<xsl:otherwise>
				<!--xsl:sequence select="altova:BuildTableIndexInfo_SingleRow_Recursive($altova:seqActiveRowSpans, $altova:nodeRow, $altova:nColumn + 1, $altova:nCellInCurrentRow, $altova:nColSpanInCellRemaining, $altova:bColSpanBegins, $altova:nCurrentSum + 1, $altova:nRowSpansToAdd + 1)"/-->
				<xsl:call-template name="altova:BuildTableIndexInfo_SingleRow_Recursive">
					<xsl:with-param name="altova:seqActiveRowSpans" select="$altova:seqActiveRowSpans"/>
					<xsl:with-param name="altova:nodeRow" select="$altova:nodeRow"/>
					<xsl:with-param name="altova:nColumn" select="$altova:nColumn + 1"/>
					<xsl:with-param name="altova:nCellInCurrentRow" select="$altova:nCellInCurrentRow"/>
					<xsl:with-param name="altova:nColSpanInCellRemaining" select="$altova:nColSpanInCellRemaining"/>
					<xsl:with-param name="altova:bColSpanBegins" select="$altova:bColSpanBegins"/>
					<xsl:with-param name="altova:nCurrentSum" select="$altova:nCurrentSum + 1"/>
					<xsl:with-param name="altova:nRowSpansToAdd" select="$altova:nRowSpansToAdd + 1"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:function name="altova:BuildTableIndexInfo_ActiveRowSpans_Recursive" as="xs:integer*">
		<xsl:param name="altova:seqRowSpans" as="xs:integer*"/>
		<xsl:param name="altova:nodeCurrentRow" as="node()"/>
		<xsl:param name="altova:nColumn" as="xs:integer"/>
		<xsl:param name="altova:nCellInCurrentRow" as="xs:integer"/>
		<xsl:param name="altova:nColSpanInCellRemaining" as="xs:integer"/>
		<xsl:choose>
			<xsl:when test="$altova:nColumn gt count($altova:seqRowSpans)">
				<xsl:sequence select="()"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:nRowSpanForCurrentColumn" select="altova:BuildTableIndexInfo_ActiveRowSpans_SingleColumn($altova:seqRowSpans, $altova:nodeCurrentRow, $altova:nColumn, $altova:nCellInCurrentRow)" as="xs:integer?"/>
				<xsl:sequence select="$altova:nRowSpanForCurrentColumn"/>
				<xsl:variable name="altova:nCellInCurrentRow_New" select="if ($altova:seqRowSpans[$altova:nColumn] eq 0 and $altova:nColSpanInCellRemaining eq 1) then $altova:nCellInCurrentRow + 1 else $altova:nCellInCurrentRow" as="xs:integer"/>
				<xsl:variable name="altova:nColSpanInCell_New" select="if ($altova:seqRowSpans[$altova:nColumn] eq 0 and $altova:nCellInCurrentRow eq $altova:nCellInCurrentRow_New) then $altova:nColSpanInCellRemaining - 1 else if (empty(altova:GetCellFromRow($altova:nodeCurrentRow, $altova:nCellInCurrentRow_New))) then 1 else altova:col-span(altova:GetCellFromRow($altova:nodeCurrentRow, $altova:nCellInCurrentRow_New))" as="xs:integer"/>
				<xsl:variable name="altova:seqRowSpansForFollowingColumns" select="altova:BuildTableIndexInfo_ActiveRowSpans_Recursive($altova:seqRowSpans, $altova:nodeCurrentRow, $altova:nColumn + 1, $altova:nCellInCurrentRow_New, $altova:nColSpanInCell_New)" as="xs:integer*"/>
				<xsl:sequence select="$altova:seqRowSpansForFollowingColumns"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:BuildTableIndexInfo_ActiveRowSpans_SingleColumn" as="xs:integer?">
		<xsl:param name="altova:seqRowSpans" as="xs:integer*"/>
		<xsl:param name="altova:nodeCurrentRow" as="node()"/>
		<xsl:param name="altova:nColumn" as="xs:integer"/>
		<xsl:param name="altova:nCellInCurrentRow" as="xs:integer"/>
		<xsl:choose>
			<xsl:when test="$altova:seqRowSpans[$altova:nColumn] gt 0">
				<xsl:sequence select="$altova:seqRowSpans[$altova:nColumn] - 1"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="altova:nodeCell" select="altova:GetCellFromRow($altova:nodeCurrentRow, $altova:nCellInCurrentRow)" as="node()"/>
				<xsl:variable name="altova:nRowSpan" select="altova:GetRowspanFromCell($altova:nodeCell) - 1" as="xs:integer"/>
				<xsl:sequence select="$altova:nRowSpan"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:GetChartYValuesForSingleSeries">
		<xsl:param name="seqCategoryLeafPos" as="node()*"/>
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:for-each select="$seqCategoryLeafPos">
			<xsl:element name="altova:Value">
				<xsl:value-of select="altova:GetChartYValueForSingleSeriesPos($nodeSeriesLeafPos, ., $bValuesInCategory)"/>
			</xsl:element>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="altova:GetChartYValueForSingleSeriesPos">
		<xsl:param name="nodeSeriesLeafPos" as="node()"/>
		<xsl:param name="nodeCategoryLeafPos" as="node()"/>
		<xsl:param name="bValuesInCategory" as="xs:boolean"/>
		<xsl:variable name="altova:seqCategoryContextIds" select="$nodeCategoryLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:seqSeriesContextIds" select="$nodeSeriesLeafPos/altova:Context/@altova:ContextId" as="xs:string*"/>
		<xsl:variable name="altova:sCommonContextId" select="for $i in $altova:seqCategoryContextIds return if (some $j in $altova:seqSeriesContextIds satisfies $i eq $j) then $i else ()" as="xs:string*"/>
		<xsl:choose>
			<xsl:when test="count($altova:sCommonContextId) gt 1">
				<xsl:message select="concat('Found several values instead of a single one (contexts: ', string-join($altova:sCommonContextId, ', '), ').')" terminate="yes"/>
			</xsl:when>
			<xsl:when test="count($altova:sCommonContextId) lt 1">
				<xsl:message select="concat('XBRL Chart: Info: No value found for position labeled &quot;', $nodeCategoryLeafPos/@altova:sLabel, '&quot;')" terminate="no"/>
				<xsl:sequence select="'altova:no-value'"/>
			</xsl:when>
			<xsl:when test="$bValuesInCategory">
				<xsl:sequence select="xs:string($nodeCategoryLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:sequence select="xs:string($nodeSeriesLeafPos/altova:Context[@altova:ContextId eq $altova:sCommonContextId]/@altova:Value)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:GetChartLabelForPos" as="xs:string">
		<xsl:param name="nodeParam" as="node()"/>
		<xsl:value-of select="string-join($nodeParam/ancestor-or-self::altova:Pos/@altova:sLabel, ' ')"/>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-pixel" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="substring-before($normLength, 'px')"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * $altova:nPxPerIn"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * $altova:nPxPerIn div 2.54"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'mm')) * $altova:nPxPerIn div 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * $altova:nPxPerIn div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * $altova:nPxPerIn div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$normLength"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
	<xsl:function name="altova:convert-length-to-mm" as="xs:decimal">
		<xsl:param name="altova:length"/>
		<xsl:variable name="normLength" select="normalize-space($altova:length)"/>
		<xsl:choose>
			<xsl:when test="ends-with($normLength, 'px')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'px')) div $altova:nPxPerIn * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'in')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'in')) * 25.4"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'cm')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'cm')) * 10"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'mm')">
				<xsl:value-of select="substring-before($normLength, 'mm') "/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pt')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pt')) * 25.4 div 72.0"/>
			</xsl:when>
			<xsl:when test="ends-with($normLength, 'pc')">
				<xsl:value-of select="xs:decimal(substring-before($normLength, 'pc')) * 25.4 div 6.0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="number($normLength) div $altova:nPxPerIn * 25.4"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:function>
</xsl:stylesheet>
